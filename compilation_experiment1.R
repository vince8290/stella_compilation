# Clear global environment
rm(list = ls())

##############################################################################################
#  HOW TO USE ?
##############################################################################################
# In a single folder named as stated in variable rawfolder must be found :
#   - all the rawdata files generated by LeafTool
#   - a mapping file with columns named : X, Label, rep, construct, leaf
#   - a nomenclature file with columns named : old.name, final.name, group,	order
#-------------------------------------------------------------------------------
#

##############################################################################################

##############################################################################################
# Configuration
##############################################################################################
setwd("D:/Mes Donnees/_PROJETS/stella")

#--------------------------------- rawdata -------------------------------------
# rawfolder: name of the folder containing the raw data files,
# relative to working directory
rawfolder = "rawdata"


# filename_pattern: Regular expression pattern to match in rawdata file names.
# the script will consider only files containing this string in file name
# Useful to analyse several, independent datasets in the same folder
# NB : Do not forget to add * wherever variable characters are expected
# * means "any number of any character"
# default (filename_pattern = "*") will consider all the files in rawfolder
# ex1 : "results_*" will only return files starting with "results_"
# ex2 : "*Results*" will only return files containing "Results" in file name
filename_pattern = "*"


# raw_ext: Raw datafiles extension ("csv", "tsv", "txt") WITHOUT the dot (.)
raw_ext = "csv"

sep = ","   # column separator for raw data files (";" or "," or "\t")
dec = "."   # decimal character for raw data files("." or ",")

# outfolder: name of the folder to which exporting result files
outfolder = "results" # name of the folder to which exporting result files


# mapping file parameters
mapping = "mapping.csv" # mapping file name
mapping_sep = ";"   # column separator for mapping file (";" or "," or "\t")
mapping_dec = ","   # decimal character for mapping file ("." or ",")


# mapping file parameters
nomenc = "nomenclature1.csv" # nomenclature file name
nomenc_sep = ";"   # column separator in nomenclature file (";" or "," or "\t")
nomenc_dec = ","   # decimal character in nomenclature file ("." or ",")


# misc
# List of leaves to analyse. values must be found in mapping file's "Leaf" column
leaves_to_keep = c("1","1'","4","4'")


# Graphics options
graph_unit = "cm"   # unit for graphs sizes ("cm", "in" or "mm" )
graph_width = 15    # graph width
graph_height = 10   # graph height
graph_dpi = 600     # graph resolution (typically between 100 and 1200)
plot_device = "png" # graph file extension

##############################################################################################
# import required libraries
##############################################################################################

require(dplyr)
require(ggplot2)
require(tools)




##############################################################################################
# Process files
##############################################################################################

#-------------------------- Get list of rawdata files --------------------------
rawdata_folder = file.path(getwd(), rawfolder)
filelist = dir(path=rawdata_folder, pattern=paste0(filename_pattern))

# exclude mapping and nomenc files
filelist = filelist[filelist != mapping]
filelist = filelist[filelist != nomenc]

# exclude files with wrong extension
filelist = filelist[ lapply(filelist, file_ext)==raw_ext]

#
# filelist=c("1 1'ResultsStella.csv",
#        "1-2ResultsStella.csv",
#        "3-4ResultsStella.csv",
#        "4 4'ResultsStella.csv",
#        "1+1'+4+4' ResultsStella.csv")

#-------------Compile all rawdata files and merge with mapping file ------------


# create dataframe
df <- data.frame()

# append each rawdata file to dataframe
for (i in 1:length(filelist)){
  tmp = read.csv2(file.path(rawfolder, filelist[i]), sep=sep, dec=dec)
  tmp$file = filelist[i]
  tmp = tmp[c( "X", "Label","Area","Mean","MinThr","MaxThr","file")]
  df <- rbind(df, tmp)
}

# extract Label from data
df$Label = as.character(df$Label)
cs <- strsplit(df$Label,'.', fixed=TRUE)
cs2 <- data.frame(do.call(rbind,cs),stringsAsFactors=FALSE)
names(cs2) <- c("label","coord")
df$Label = cs2$label


#-------------------------- import mapping file --------------------------------
mdf = read.csv2(file.path(rawfolder, mapping), sep=mapping_sep, dec=mapping_dec)
mdf$rep <- factor(mdf$rep) # factorize replicate column



#----------------------- merge mapping file with data --------------------------
df2 <- merge(df, mdf[c("X", "Label","rep","construct","leaf")],by=c("X", "Label"),sort=FALSE)

#-------- subsetting : keep only data for leaves # 1, 1', 4, 4' ----------------
df3 = df2[df2$leaf %in% leaves_to_keep,]


# backup "old.construct" names just in case
names(df3)[names(df3) == 'construct'] <- 'old.construct'

# rename "Mean" column to "surface"
names(df3)[names(df3) == 'Mean'] <- 'surface'

# Modify construct names using "nomenclature.csv"
corresp <- read.csv2(file.path(rawfolder, nomenc), sep=nomenc_sep, dec=nomenc_dec, as.is=TRUE)
names(corresp) <- c("old.construct","construct","group","order")

# Merge df3 and corresp in new data frame (introduces the column "construct" in front of the corresponding "old.construct" column)
df4 <- merge(df3,corresp,all.x=TRUE,sort=FALSE)

# list columns to keep
df4 = df4[c("X", "Label","surface","file","old.construct","construct","group","rep", "leaf","order")]
df4 <- df4[order(df4$order),]

df4$construct[is.na(df4$construct)] <- df4$old.construct[is.na(df4$construct)]

# check variables
unique(df4[c("old.construct","construct","rep")])

# Create construct.rep from the construct name in nomenclature.csv
df4$construct.rep <- paste(df4$construct,df4$rep,sep='.')

# Convert columns format from character to factor
df4$construct <- factor(df4$construct, levels=unique(df4$construct))
df4$group <- factor(df4$group, levels=unique(df4$group))
df4$rep <- factor(df4$rep)
df4$construct.rep <- factor(df4$construct.rep)

# create output folder if it doesnt exist
dir.create(outfolder, showWarnings = FALSE)

# Export final dataframe to .RData file
save(df4, file=file.path(outfolder,"df4.RData"))



##############################################################################################
# Create boxplots from transformed data frame
##############################################################################################

# Re-import data if necessary (if scripts are saved separately)
if (!exists("df4")) {load(file.path(outfolder,"df4.RData"))}

# Calculate means and variances (for "construct.rep") and create a data frame
ag1 <- aggregate(df4$surface,df4["construct.rep"],mean) ; names(ag1)[2] <- "mean"
ag2 <- aggregate(df4$surface,df4["construct.rep"],var) ; names(ag2)[2] <- "variance"
ag <- merge(ag1,ag2)


# visualize standard deviation/mean
ggplot(ag, aes(x=mean, y=sqrt(variance)))+
  geom_point(shape=1) +
  geom_smooth(method="lm", se=FALSE) +
  ggtitle("standard deviation") + xlab("mean") + ylab("standard deviation") +
  theme_bw()

# Save last plot using graphics settings
# Change the name of the output file if you want
# filename (without extension)
fn = "sd_vs_mean"
ggsave(filename= paste0(fn, ".", plot_device),
       path = outfolder,
       device=plot_device,
       width=graph_width,
       height=graph_height,
       unit=graph_unit,
       dpi=graph_dpi)



# Create a table from df4 with columns "construct.rep", "construct", and "rep"
construct.rep <- unique(df4[c("construct.rep","construct","rep")])

# Calculate mean per construct
ag <- aggregate(df4$surface,df4[c("construct")],mean)

# Transform the data for statistical analyses (choose below which transformation is best suited)
trans <- function(x) x # No transformation (raw data)
# trans <- function(x) x^0.5 # Power Transformation
# trans <- log10 # Log Transformation




# Create Boxplot labels
labels <- c(5000, 10000, 15000, 20000, 25000, 30000)

# Transform labels to fit the data transformation
breaks <- trans(labels)

# Create a horizontal boxplot
ggplot(df4, aes(x=construct,y=trans(surface))) +
  theme_classic() +
  coord_flip() +
  theme(legend.position="none",axis.text = element_text(face="bold",size=10)) +
  scale_x_discrete(limits=levels(df4$order)) +
  scale_y_continuous(breaks=breaks, labels=labels) +
  labs(x="", y="Grey level (AU)") +
  geom_boxplot(outlier.color = "white", aes(fill=group), alpha=1) +
  geom_point(position=position_jitterdodge(jitter.width=0, dodge.width = 0.3), cex=3, alpha=0.3,
             aes(color=factor(rep)), show.legend = F) +
  scale_fill_manual(values=c("#ffeeaa", "#ffeeaa", "#aedabc","#a0efab","#abcdef"))

# Save last boxplot using graphics settings
# Change the name of the output file if you want
# filename (without extension)
fn = "graph_horiz"
ggsave(filename= paste0(fn, ".", plot_device),
       path = outfolder,
       device=plot_device,
       width=graph_width,
       height=graph_height,
       unit=graph_unit,
       dpi=graph_dpi)


# Create a vertical boxplot (several options available: violin etc. See ggplot plots in R supporting documentation)
ggplot(df4, aes(x=construct,y=trans(surface))) +
  theme_classic() +
  theme(legend.position="none",axis.text = element_text(face="bold",size=10), axis.text.x=element_text(angle=90, hjust=1)) +
  scale_x_discrete(limits=levels(df4$construct)) +
  scale_y_continuous(breaks=breaks, labels=labels) +
  labs(x="", y="Grey level (AU)") +
  geom_boxplot(outlier.color = "white", aes(fill=group, alpha=0.1)) +
  geom_point(position=position_jitterdodge(jitter.width=0.0, dodge.width = 0.3), cex=3, alpha=0.3,
             aes(color=factor(rep)), show.legend = F)

# Save last boxplot using graphics settings
# Change the name of the output file if you want
# filename (without extension)
fn = "graph_vert"
ggsave(filename= paste0(fn, ".", plot_device),
       path = outfolder,
       device=plot_device,
       width=graph_height,
       height=graph_width,
       unit=graph_unit,
       dpi=graph_dpi)



##############################################################################################
## Statistical Analyses
##############################################################################################

# Load functions used in the Tukey test (should be in the working directory)
source("tukey.r")

# Re-import data if necessary (if scripts are saved separately)
# load("df4.RData")

# Anova and Shapiro test No transformation
mod <- lm(surface~construct+construct:rep,data=df4)
anova(mod)
windows() ; hist(mod$res)
windows() ; qqnorm(mod$res, main=paste("No trans")) ; qqline(mod$res)
shapiro.test(mod$res)

# Anova and Shapiro test Log transformation
mod <- lm(log(surface)~construct+construct:rep,data=df4)
anova(mod)
windows() ; hist(mod$res)
windows() ; qqnorm(mod$res, main=paste("transformation log")) ; qqline(mod$res)
shapiro.test(mod$res)

# Anova and Shapiro test power transformation (see with Francois Bonnot)
mod <- lm(surface^0.5~construct+construct:rep,data=df4)
anova(mod)
windows() ; hist(mod$res)
windows() ; qqnorm(mod$res, main=paste("power transformation")) ; qqline(mod$res)
shapiro.test(mod$res)


#-------------------------------------------------------------------------------
# data transformation for statistical analysis ? (choose between No transformation, Log transformation or power transformation)
trans_stat <- function(x) x # No transformation (raw data)
# trans_stat <- function(x) x^0.5 # Power Transformation (^0.5 = square root)
# trans_stat <- log10 # Log Transformation

conf.level=0.95 #confidence interval (0.95 for alpha = 0.05)


#-------------------------------------------------------------------------------
# Multiple comparisons AOV test for construct 
mod <- aov(trans_stat(surface)~construct+construct:rep,data=df4)
anova(mod)
model.tables(mod,type="means",cterms="construct") #check model

# Tukey HSD test and grouping for "construct".
TukeyHSD.group.FUN(mod,"construct",hole.rm=TRUE, FUN=trans_stat, conf.level=conf.level)

# extract p.adj values for "construct" to csv file
tuk <- TukeyHSD(mod,"construct",ordered=FALSE, conf.level=conf.level)
res <- data.frame(tuk$"construct")
res["p.adj"]
write.csv2(res["p.adj"], file=file.path(outfolder,"p_adjusted.csv"))

# If transformation applied, export p-values for transformed values to csv file
if (all(df4$surface == trans_stat(df4$surface)) != TRUE) {
  print("export adjusted p-values for transformed data")
  mod <- aov(trans_stat(surface)~construct+construct:rep,data=df4)
  anova(mod)
  model.tables(mod, type="means",cterms="construct")
  tuk <- TukeyHSD(mod,"construct",ordered=FALSE, conf.level=conf.level)
  res <- data.frame(tuk$"construct")
  res["p.adj"]
  write.csv2(res["p.adj"], file=file.path(outfolder,"p_adjusted_trans.csv"))
  }


#-------------------------------------------------------------------------------
# Multiple comparisons AOV test for construct.rep 
mod <- aov(trans_stat(surface)~construct.rep,data=df4)
anova(mod)
model.tables(mod,type="means",cterms="construct.rep") #check model

# Tukey HSD test and grouping for "construct".
TukeyHSD.group.FUN(mod,"construct.rep",hole.rm=TRUE, FUN=trans_stat, conf.level=conf.level)

# extract p.adj values for "construct" to csv file
tuk <- TukeyHSD(mod,"construct.rep",ordered=FALSE, conf.level=conf.level)
res <- data.frame(tuk$"construct.rep")
res["p.adj"]
write.csv2(res["p.adj"], file=file.path(outfolder,"p_adjusted.csv"))

# If transformation applied, export p-values for transformed values to csv file
if (all(df4$surface == trans_stat(df4$surface)) != TRUE) {
  print("export adjusted p-values for transformed data")
  mod <- aov(trans_stat(surface)~construct.rep,data=df4)
  anova(mod)
  model.tables(mod, type="means",cterms="construct.rep")
  tuk <- TukeyHSD(mod,"construct.rep",ordered=FALSE, conf.level=conf.level)
  res <- data.frame(tuk$"construct.rep")
  res["p.adj"]
  write.csv2(res["p.adj"], file=file.path(outfolder,"p_adjusted_trans.csv"))
  }


## --------------- End of multiple comparisons ------------------








## ----Optional tests ----------------------------------------------------

shapiro <- function(lambda) {
  mod <- lm(surface^lambda~construct+construct:rep,data=df4)
  shapiro.test(mod$res)$stat
}

qncor <- function(lambda) {
  mod <- lm(surface^lambda~construct+construct:rep,data=df4)
  qn <- qqnorm(mod$res,plot.it=FALSE)
  cor(qn$x,qn$y)
}

bart <- function(lambda) {
  bartlett.test(surface^lambda~construct.rep,data=df4)$stat
}

qncor(1)

x <- seq(0.01,1,0.01)
s <- sapply(x,shapiro)
q <- sapply(x,qncor)
b <- sapply(x,bart)

windows()
plot(x,s,type='l')
(lambda <- x[s==max(s)])
abline(v=lambda)

windows()
plot(x,q,type='l')
(lambda <- x[q==max(q)])
abline(v=lambda)

windows()
plot(x,b,type='l')
(lambda <- x[b==min(b)])
abline(v=lambda)

## ------------- end of file ------------------------------------------------------------------------------






